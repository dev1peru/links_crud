<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Links CRUD</title>

  <!-- SortableJS (drag & drop) -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>

  <style>
    :root{
      --bg:#f6f7fb;
      --card:#ffffff;
      --text:#121826;
      --muted:#667085;
      --line:#e6e8ef;
      --btn:#111827;
      --btnText:#fff;
      --danger:#e11d48;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
    }

    /* ✅ Make links look "designed" (no default blue underline) */
    a{
      color: inherit;
      text-decoration: none;
    }
    a:hover{
      text-decoration: underline;
    }

    header{
      padding:18px 22px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    h1{margin:0;font-size:22px}
    .topbar{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .btn{
      border:0;
      background:var(--btn);
      color:var(--btnText);
      padding:8px 12px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
      font-size:13px;
    }
    .btn.secondary{
      background:#fff;
      color:#111827;
      border:1px solid var(--line);
    }
    .btn.danger{
      background:var(--danger);
    }

    .wrap{
      padding:0 22px 28px;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* ✅ 3 cards per row on desktop */
    .sections-grid{
      display:grid;
      grid-template-columns: repeat(3, minmax(320px, 1fr));
      gap:14px;
      align-items:start;
    }

    /* ✅ responsive breakpoints */
    @media (max-width: 1100px){
      .sections-grid{ grid-template-columns: repeat(2, minmax(320px, 1fr)); }
    }
    @media (max-width: 720px){
      .sections-grid{ grid-template-columns: 1fr; }
      header{ flex-direction: column; align-items:flex-start; }
      .topbar{ width:100%; justify-content:flex-end; }
    }

    .card{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      box-shadow: 0 2px 10px rgba(16,24,40,.04);
      min-height: 90px;
    }

    /* ✅ Colored section header */
    .card-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;

      padding:10px 12px;
      margin:-12px -12px 10px;
      border-radius:14px 14px 10px 10px;
      background: var(--secBg, #ffffff);
      color: var(--secText, var(--text));
      border-bottom: 1px solid rgba(0,0,0,.06);
    }

    .card-title{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight:800;
    }
    .drag-handle{
      user-select:none;
      cursor:grab;
      font-weight:900;
      color:var(--muted);
    }
    .dragging .drag-handle{cursor:grabbing}

    .muted{color:var(--muted); font-size:12px}

    .links{
      margin-top:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:6px;
      border-radius:12px;
      border:1px dashed transparent;
    }

    .link-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:8px 10px;
      background:#fafbff;
      border:1px solid #eef1f7;
      border-radius:10px;
    }
    .link-left{
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
    }
    .link-title{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      font-weight:650;
    }

    /* ✅ Hide URL line under each title */
    .link-url{ display:none; }

    .mini-actions{
      display:flex;
      align-items:center;
      gap:6px;
      flex-shrink:0;
    }

    .icon-btn{
      border:1px solid var(--line);
      background:#fff;
      padding:6px 8px;
      border-radius:10px;
      cursor:pointer;
      font-weight:700;
      font-size:12px;
      line-height:1;
    }
    .icon-btn.danger{
      border-color: #ffd1dc;
      color: #b42318;
      background:#fff5f7;
    }

    /* keep buttons readable on colored headers */
    .card-header .icon-btn{
      background: rgba(255,255,255,.85);
    }

    /* dropdown style */
    .color-select{
      border:1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.9);
      border-radius:10px;
      padding:6px 8px;
      font-weight:650;
      font-size:12px;
      cursor:pointer;
    }

    .edit-only{ display:none; }
    body.editing .edit-only{ display:inline-flex; }
    body.editing select.edit-only{ display:inline-flex; }
    body.editing .links{ border-color:#d1d5ff; background:#f6f7ff; }
    body.editing .card{ outline: 1px solid #dbe0ff; }

    .add-area{
      display:none;
      margin-top:10px;
      gap:8px;
      flex-direction:column;
    }
    body.editing .add-area{ display:flex; }

    input{
      width:100%;
      padding:9px 10px;
      border:1px solid var(--line);
      border-radius:10px;
      outline:none;
      font-size:13px;
      background:#fff;
    }

    .row{
      display:flex;
      gap:8px;
    }

    .hint{
      font-size:12px;
      color:var(--muted);
      margin-top:10px;
    }
  </style>
</head>

<body>
  <header>
    <div>
      <h1>My Links</h1>
      <div class="muted">Read mode by default. Click <b>Edit</b> to reorder / add / delete.</div>
    </div>
    <div class="topbar">
      <button id="editBtn" class="btn secondary">Edit</button>
      <button id="saveBtn" class="btn" style="display:none;">Save</button>
    </div>
  </header>

  <div class="wrap">
    <div id="addSectionTop" class="row edit-only" style="margin-bottom:14px;">
      <input id="newSectionName" placeholder="New section name (e.g. Tools)" />
      <button class="btn" id="addSectionBtn">Add Section</button>
    </div>

    <div id="sectionsGrid" class="sections-grid"></div>

    <div class="hint">
      Tip: In Edit mode you can drag sections and links. In Read mode: no accidental deletes.
    </div>
  </div>

<script>
  const API = ""; // same origin

  const COLOR_THEME = {
    slate:  { bg:"#eef2f7", text:"#111827" },
    blue:   { bg:"#e6f0ff", text:"#0b1f44" },
    green:  { bg:"#e8f7ee", text:"#0b2a16" },
    amber:  { bg:"#fff3d6", text:"#3a2a05" },
    red:    { bg:"#ffe7ea", text:"#3b0a12" },
    purple: { bg:"#f1e8ff", text:"#24113a" },
    pink:   { bg:"#ffe8f2", text:"#3a0b22" },
    teal:   { bg:"#e6fbf8", text:"#062c2a" },
  };
  const COLOR_OPTIONS = Object.keys(COLOR_THEME);

  let state = {
    editMode: false,
    sections: [],
    sectionSortable: null,
    linkSortables: new Map(),
    pendingSectionColors: new Map(), // section_id -> color (staged until Save)
  };

  const elGrid = document.getElementById("sectionsGrid");
  const editBtn = document.getElementById("editBtn");
  const saveBtn = document.getElementById("saveBtn");

  function setEditMode(on){
    state.editMode = on;
    document.body.classList.toggle("editing", on);
    editBtn.style.display = on ? "none" : "inline-flex";
    saveBtn.style.display = on ? "inline-flex" : "none";
    render();
    if(on) enableSortables();
    else destroySortables();
  }

  editBtn.addEventListener("click", () => {
    state.pendingSectionColors.clear();
    setEditMode(true);
  });

  saveBtn.addEventListener("click", async () => {
    try{
      // Persist staged colors only when user hits Save
      for (const [sectionId, color] of state.pendingSectionColors.entries()){
        await apiPut(`/sections/${sectionId}`, { color });
      }
      state.pendingSectionColors.clear();
      setEditMode(false);
      await load(); // refresh with saved colors
    }catch(err){
      alert("Save failed: " + err);
    }
  });

  document.getElementById("addSectionBtn").addEventListener("click", async () => {
    const name = document.getElementById("newSectionName").value.trim();
    if(!name) return alert("Type a section name");
    await apiPost("/sections", {name});
    document.getElementById("newSectionName").value = "";
    await load();
  });

  async function apiGet(path){
    const r = await fetch(API + path);
    if(!r.ok) throw new Error(await r.text());
    return r.json();
  }
  async function apiPost(path, body){
    const r = await fetch(API + path, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(body)
    });
    if(!r.ok) throw new Error(await r.text());
    return r.json();
  }
  async function apiPut(path, body){
    const r = await fetch(API + path, {
      method:"PUT",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(body)
    });
    if(!r.ok) throw new Error(await r.text());
    return r.json();
  }
  async function apiDelete(path){
    const r = await fetch(API + path, { method:"DELETE" });
    if(!r.ok) throw new Error(await r.text());
    return r.json();
  }

  function escapeHtml(s){
    return (s ?? "").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function render(){
    elGrid.innerHTML = "";

    for(const sec of state.sections){
      const card = document.createElement("div");
      card.className = "card";
      card.dataset.sectionId = sec.id;

      const effectiveColor = state.pendingSectionColors.get(sec.id) ?? sec.color ?? "slate";
      const theme = COLOR_THEME[effectiveColor] ?? COLOR_THEME.slate;

      card.style.setProperty("--secBg", theme.bg);
      card.style.setProperty("--secText", theme.text);

      card.innerHTML = `
        <div class="card-header">
          <div class="card-title">
            <span class="drag-handle edit-only" title="Drag section">⠿</span>
            <span>${escapeHtml(sec.name)}</span>
            <button class="icon-btn edit-only" data-action="rename-section" data-section-id="${sec.id}" title="Rename">✎</button>
          </div>

          <div class="mini-actions">
            <select class="color-select edit-only" data-action="color-section" data-section-id="${sec.id}">
              ${COLOR_OPTIONS.map(c => `
                <option value="${c}" ${c === effectiveColor ? "selected" : ""}>${c}</option>
              `).join("")}
            </select>

            <button class="icon-btn danger edit-only" data-action="delete-section" data-section-id="${sec.id}" title="Delete section">Del</button>
          </div>
        </div>

        <div class="links" id="links-${sec.id}">
          ${sec.links.map(l => `
            <div class="link-row" data-link-id="${l.id}">
              <div class="link-left">
                <span class="drag-handle edit-only" title="Drag link">⠿</span>
                <div style="min-width:0;">
                  <div class="link-title">
                    <a href="${escapeHtml(l.url)}" target="_blank" rel="noreferrer">${escapeHtml(l.title)}</a>
                  </div>
                  <div class="link-url">${escapeHtml(l.url)}</div>
                </div>
              </div>

              <div class="mini-actions edit-only">
                <button class="icon-btn" data-action="edit-link" data-link-id="${l.id}">Edit</button>
                <button class="icon-btn danger" data-action="delete-link" data-link-id="${l.id}">Del</button>
              </div>
            </div>
          `).join("")}
        </div>

        <div class="add-area">
          <div class="row">
            <input placeholder="Title" id="title-${sec.id}">
            <input placeholder="https://..." id="url-${sec.id}">
            <button class="btn" data-action="add-link" data-section-id="${sec.id}">Add</button>
          </div>
        </div>
      `;

      elGrid.appendChild(card);
    }

    elGrid.querySelectorAll("[data-action]").forEach(btn => {
      btn.addEventListener("click", handleActionClick);
    });

    // The color dropdown uses "change" events (not click)
    elGrid.querySelectorAll('select[data-action="color-section"]').forEach(sel => {
      sel.addEventListener("change", handleActionClick);
    });
  }

  async function handleActionClick(e){
    const a = e.currentTarget.dataset.action;

    try{
      if(a === "color-section"){
        const sectionId = Number(e.currentTarget.dataset.sectionId);
        const color = e.currentTarget.value;
        state.pendingSectionColors.set(sectionId, color);

        // preview immediately
        render();
        if(state.editMode) enableSortables();
        return;
      }

      if(a === "delete-section"){
        const id = Number(e.currentTarget.dataset.sectionId);
        if(confirm("Delete section and all links?")){
          await apiDelete(`/sections/${id}`);
          await load();
        }
      }

      if(a === "rename-section"){
        const id = Number(e.currentTarget.dataset.sectionId);
        const sec = state.sections.find(s => s.id === id);
        const name = prompt("New section name:", sec?.name ?? "");
        if(name && name.trim()){
          await apiPut(`/sections/${id}`, { name: name.trim() });
          await load();
        }
      }

      if(a === "add-link"){
        const sectionId = Number(e.currentTarget.dataset.sectionId);
        const title = document.getElementById(`title-${sectionId}`).value.trim();
        const url = document.getElementById(`url-${sectionId}`).value.trim();
        if(!title) return alert("Title required");
        if(!url) return alert("URL required");
        await apiPost(`/sections/${sectionId}/links`, { title, url });
        document.getElementById(`title-${sectionId}`).value = "";
        document.getElementById(`url-${sectionId}`).value = "";
        await load();
      }

      if(a === "delete-link"){
        const linkId = Number(e.currentTarget.dataset.linkId);
        if(confirm("Delete this link?")){
          await apiDelete(`/links/${linkId}`);
          await load();
        }
      }

      if(a === "edit-link"){
        const linkId = Number(e.currentTarget.dataset.linkId);

        let found = null;
        for(const s of state.sections){
          const l = s.links.find(x => x.id === linkId);
          if(l){ found = l; break; }
        }
        if(!found) return;

        const newTitle = prompt("Title:", found.title);
        if(newTitle === null) return;

        const newUrl = prompt("URL:", found.url);
        if(newUrl === null) return;

        await apiPut(`/links/${linkId}`, { title: newTitle.trim(), url: newUrl.trim() });
        await load();
      }

    }catch(err){
      alert(String(err));
    }
  }

  function destroySortables(){
    if(state.sectionSortable){
      state.sectionSortable.destroy();
      state.sectionSortable = null;
    }
    for(const s of state.linkSortables.values()){
      try{ s.destroy(); }catch(_){}
    }
    state.linkSortables.clear();
  }

  function enableSortables(){
    destroySortables();

    // Sections sortable
    state.sectionSortable = new Sortable(elGrid, {
      animation: 150,
      handle: ".card-header .drag-handle",
      draggable: ".card",
      onStart: () => document.body.classList.add("dragging"),
      onEnd: async () => {
        document.body.classList.remove("dragging");
        const ordered = [...elGrid.querySelectorAll(".card")]
          .map(c => Number(c.dataset.sectionId))
          .filter(n => Number.isFinite(n));

        try{
          await apiPut("/sections-reorder", { ordered_ids: ordered });
        }catch(err){
          alert("Section reorder failed: " + err);
        }
      }
    });

    // Links sortable
    for(const sec of state.sections){
      const listEl = document.getElementById(`links-${sec.id}`);
      if(!listEl) continue;

      const sortable = new Sortable(listEl, {
        animation: 150,
        handle: ".drag-handle",
        draggable: ".link-row",
        onStart: () => document.body.classList.add("dragging"),
        onEnd: async () => {
          document.body.classList.remove("dragging");
          const ordered = [...listEl.querySelectorAll(".link-row")]
            .map(r => Number(r.dataset.linkId))
            .filter(n => Number.isFinite(n));

          try{
            await apiPut(`/sections/${sec.id}/links-reorder`, { ordered_ids: ordered });
          }catch(err){
            alert("Link reorder failed: " + err);
          }
        }
      });

      state.linkSortables.set(sec.id, sortable);
    }
  }

  async function load(){
    state.sections = await apiGet("/sections");
    render();
    if(state.editMode) enableSortables();
  }

  load().catch(err => alert(String(err)));
</script>
</body>
</html>
